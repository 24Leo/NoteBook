[参考](https://blog.csdn.net/u011784767/article/details/76824822)
Redis对客户端响应请求的工作模型是单进程和单线程的。
再次确定一个问题，客户端发起更新操作时：
    * 客户端将数据发送（此时数据在客户端内存中）
    * 服务器收到数据（服务器内存中）
    * 服务器调用write写入磁盘（操作系统缓存中）
    * save等方法促使fsync写入磁盘（磁盘缓存中）
    * 写入磁盘（磁盘中）。

所以可以明确一点：
    * **redis服务器主进程在处理客户端请求时也会占用操作系统IO**
    * 所以子进程备份时有可能会相互阻塞：主进程服务可能受到影响。
    
##两种
除了官方的两种，还可以自定义。
###RDB
* RDB模式下就是生成一个数据库的快照snapshot，默认名dump.rdb。
* 频率：
    * 在redis.conf中可以配置
        * save 900 1 ： 代表每900S内至少1个key更改即需要快照
    * 手动出发save、bgsave命令
    * 如果配置save "" 或者手动 save "" ，那么会停止快照
* save、bgsave
    * 两者其实都是调用的阻塞接口rdbsave，不同的是父进程还是子进程阻塞！
    * save直接在主进程生成快照文件并且fsync到磁盘。
        * 主进程阻塞：不会接受任何客户端请求。
    * bgsave通过fork一个**子进程**，由子进程去生成快照并写入fsync磁盘。然后通知父进程。
        * 子进程阻塞但是父进程正常。

#####伪代码
```python
// rdbSave是阻塞的～
def SAVE():
    rdbSave()
   
def BGSAVE():
    pid = fork()
    if pid == 0:
        # 子进程保存RDB
        rdbSave()
    elif pid > 0:
        # 父进程继续处理请求，并等待子进程的完成信号
        handle_request()
    else:
        # pid == -1
        # 处理fork 错误
        handle_fork_error()
```
####优缺点
#####优点
* 文件较少，方便备份
* 性能最优：最大化redis性能。
    * 备份时fork一个子进程，不影响主进程
#####缺点
* 可能数据不完整：每隔多少时间备份就有可能少多少。
    * 完整数据备份，所以工作不轻松。间隔时间不应太短。
* 数据量大备份时内存占用*2，由于内存不足可能影响主进程性能。
* CPU时瓶颈时：fork耗时。

###AOF
####优缺点
#####优点
#####缺点
###对比

###学习
可以新建一个机器当作slave，不处理任何请求，仅两个功能：
    * 同步master
    * 生成rdb、aof文件
        * 这样主服务器就不需要生成快照、dump文件了，不会抢占IO。
主服务器就用来处理请求，某个slave专门备份～～～


[return](README.md)