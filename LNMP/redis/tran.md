* 事物命令：
    * multi 开启一个命令，对客户端接下来发送的命令放到一个队列里面
        * 直到exec命令后开始原子执行，如果发送命令中还有multi会报错（重复）
        *总是返回OK
    * exec：执行，原子性、不支持回滚
        * 返回一个数组，代表每一条命了执行的结果----也是顺序的！！
    * watch：使得exec有条件执行。check and set
        * 锁定一些键，在【锁定～执行】之间这些键不可以被修改，否则事物执行失败，但是可以重试。
        * watch之后生效，直到exec截止。
    * unwatch：不在监视某些键，exec、discard、断开链接后不需要手动执行了，会自动放弃。
    * discard：退出事物、丢弃所有命令、监视的键，然后恢复到正常连接状态
* 事物仅保证在exec命令执行过程中不被插入其他客户端命令～
* 事物原子性：要么全执行，要么全不执行。
    * 有某个、某些执行失败，但是后面会继续执行。不会回滚～
    * 返回的结果也是按命令顺序返回；
* 所以有个知识点需要明确：关于错误。
    * 入队列的错误比如语法错误：**直接取消事物discard**，所有命令GG
        * 一般入队列成功服务器返回queued，如果不是则失败，大多数会取消事物。
        * 2.6.5之后服务器记录失败情况，如果客户端调用exec时会拒绝执行并放弃该事物(一般情况下入队失败，客户端自己就取消事物了)。
    * 入队列后exec的错误比如lpop一个set：后面命令会继续～
* AOF备份时：一个事物通过一个write命令写入，如果服务器挂了，导致部分写入，那么重启redis服务时会报错，redis-check-aof可以解决不完整事物信息（直接删除）。2.2之后可以通过乐观锁watch实现CAS（check and set）。
* 为什么没有回滚？
    * Redis 命令只会因为错误的语法而失败（并且这些问题未在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。



[return](README.md)