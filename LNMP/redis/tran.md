* 事物命令：
    * multi 开启一个命令，对客户端接下来发送的命令放到一个队列里面
        * 每一个命令一次交互---网络连接次数挺多的哈～！
            * 可以使用mget、mset优化
        * 直到exec命令后开始原子执行，如果发送命令中还有multi会报错（重复）
        *总是返回OK
    * exec：执行，原子性、不支持回滚
        * 返回一个数组，代表每一条命了执行的结果----也是顺序的！！
    * watch：使得exec有条件执行。check and set
        * 锁定一些键，在【锁定～执行】之间这些键不可以被修改，否则事物执行失败(discard)，但是可以重试。
        * **乐观锁**：如果冲突了就可以重复执行，直到没有冲突竞争。
            * 抢购场景！
            * 乐观锁：每次都认为不被修改，所以读不上锁，写才上锁。
            * 悲观锁：每次都认为已被修改，所以读写都锁会阻塞别人。
    * unwatch：不在监视某些键，exec、discard、断开链接后不需要手动执行了，会自动放弃。
    * discard：退出事物、丢弃所有命令、监视的键，然后恢复到正常连接状态
* 事物仅保证在exec命令执行过程中不被插入其他客户端命令～
* 事物原子性：要么全执行，要么全不执行。
    * 有某个、某些执行失败，但是后面会继续执行。不会回滚～
        * 语法错误不会加入队列，客户端自己终止事物。
    * 返回的结果也是按命令顺序返回；
* 关于错误：有个知识点需要明确。
    * 入队列的错误比如语法错误：**直接取消事物discard**，所有命令GG
        * 一般入队列成功服务器返回queued，如果不是则失败，大多数会取消事物。
        * 2.6.5之后服务器记录失败情况，如果客户端调用exec时会拒绝执行并放弃该事物(一般情况下入队失败，客户端自己就取消事物了)。
    * 入队列后exec的错误比如lpop一个set：后面命令会继续～
* AOF备份时：一个事物通过一个write命令写入，如果服务器挂了，导致部分写入，那么重启redis服务时会报错，redis-check-aof可以解决不完整事物信息（直接删除）。2.2之后可以通过乐观锁watch实现CAS（check and set）。
* 为什么没有回滚？
    * Redis 命令只会因为错误的语法而失败（并且这些问题未在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。
* 异常
    * multi之前，很好理解都不执行
    * multi之后exec之前，
    * exex之后，所有都会执行～
* 特性
    * A 
        * 不满足原子性，因为如果一个执行失败不会回滚，而且全部执行完
    * C
        * 满足一致性。
    * I
        * 满足隔离性，不会被其他打断；
    * D
        * 不满足持久性，需要持久化支持（比如RDB模式下有可能丢失几分钟数据）。
* 内存
    * 一般最大可以95%。超过出发内存交换严重影响性能。
    * 如RDB需要45%，因为有一半要缓存，另外5%其他开销。



[return](README.md)