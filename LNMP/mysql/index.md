[索引](https://www.cnblogs.com/tgycoder/p/5410057.html)与算法：  就是目录
    * 聚集索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点
    * Innodb表本身就是B+树组织的表，叶子结点保存真实的行数据（没有另外的数据页）。另外B+树叶子结点组织成双向链表
        * 聚集索引：一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序储；data域保存真实数据行，因此没有额外数据页，因此仅有一个，
            但是可以多个列组合成一个
            聚集索引对于那些经常要搜索范围值的列特别有效
            如果用uuid的话，导致写入是乱序的，会做页分裂操作
        * 非聚集索引：一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序无关；data域保存主键值---两次遍历：第一次得主键、第二次用主键得数据
        * 聚集可以理解成拼音目录，非聚集可以为偏旁部首
    * myisam    
        * 都是非聚集，data域保存数据地址，数据和文件分离
        * 文件中顺序都是插入顺序
        
优点
    * 大大减少了服务器需要扫描的数据量
    * 可以避免排序和临时表
        * 可以利用同一索引同时进行查找和排序操作
        * 如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引。其它情况都会使用filesort
    * 可以将随机IO变为顺序IO        

误区
    * 主键就是聚集索引主键是添加唯一性约束的聚集索引？错！
键是用来处理业务相关比如唯一性、连接等，但是索引是用来提高查询性能的！不是一个概念！！！！
在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，即可以创建主键非聚集索引。
创建主键后，不可以删除该索引。如果强制删除，那么主键也没了！！！
    * 只要建立索引就能显著提高查询速度
    
原则
    * 既不能绝大多数都相同，又不能只有极少数相同
    * 列要独立
	* 指索引列不能是表达式的一部分，也不能是函数的参数
    * 前缀索引&索引选择性：使用短索引，可以提高查询速度而且可以节省磁盘空间和I/O操作。
    * “水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。
    * 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。
    * 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。
    * 尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。

    
算法 
    * 插入、分裂
    * 删除、合并
    

共享锁、排他锁、意向共享锁（事务在给一个数据行加共享锁前必须先取得该表的IS锁。），意向排他锁
共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。
InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！。



动作描述	使用聚集索引	使用非聚集索引
列经常被分组排序	应	应
返回某范围内的数据	应	不应
一个或极少不同值	不应	不应
小数目的不同值	应	不应
大数目的不同值	不应	应
频繁更新的列	不应	应
外键列	应	应
主键列	应	应
频繁修改索引列	不应	应


一次事务提交后，需要写undo、写redo、写binlog
从库读取binlog，变成relaylog保存在自己机器上，然后应用

同步复制
所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。
这样，显然不可取，也不是MYSQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。

异步复制
如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。

半同步复制
master只保证slaves中的一个操作成功，就返回，其他slave不管。
这个功能，是由google为MYSQL引入的。


磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率预读的长度一般为页（page）的整倍数。

所以从读取IO次数来评价索引数据结构优劣，根据B-Tree的定义，可知检索一次最多需要访问h个结点。B-Tree中一次检索最多需要**h-1次I/O（根结点常驻内存）**，渐进复杂度为O(h)=O(logdN)。一般实际应用中，出读d是非常大的数字，通常超过100，因此h非常小。红黑树结构，h明显要深得多。由于逻辑上很近的结点（父子结点）物理上可能离得很远，无法利用局部性原理。

第一个重大区别是InnoDB的数据文件本身就是索引文件；MyISAM索引文件和数据文件是分离的，innodb本身就是数据行
第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。


表通常具有包含唯一标识表中每一行的值的一列或一组列

主键一唯一索引的区别：

         1 一个表的主键只能有一个，而唯一索引可以建多个。
         2 主键可以作为其它表的外键。
         3 主键不可为null，唯一索引可以为null。

聚集索引并不一定是唯一索引，由于SQL SERVER将主键默认定义为聚集索引，事实上，索引是否唯一与是否聚集是不相关的，聚集索引可以是唯一索引，也可以是非唯一索引；

主键并不一定是聚集索引，只是在SQL SERVER中，未明确指出的情况下，默认将主键定义为聚集，而ORACLE中则默认是非聚集，因为SQL SERVER中的ROWID未开放使用。


MySQL 主从复制主要有以下几种方式：
 基于 SQL 语句的复制(statement-based replication, SBR)；
 基于行的复制(row-based replication, RBR)；
混合模式复制(mixed-based replication, MBR)；
 基于 SQL 语句的方式最古老的方式，也是目前默认的复制方式，后来的两种是 MySQL 5 以后才出现的复制方式。

同步复制
所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。
这样，显然不可取，也不是MYSQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。 
异步复制
如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。
半同步复制
master只保证slaves中的一个操作成功，就返回，其他slave不管。
这个功能，是由google为MYSQL引入的。



##B-树

##B+树

##[索引](http://www.cnblogs.com/ccsccs/articles/4243644.html)
* 索引的实现用B－、＋树：那么聚集索引是一棵树，非聚集索引实现也是一棵树
    * 聚集索引叶子节点是数据，索引存储顺序即数据行物理存储顺序
    * 非聚集索引叶子节点不是数据，存储指针偏移量
    * [不同](http://www.cnblogs.com/aspnethot/articles/1504082.html)
* 主键是添加唯一性约束的聚集索引？**错！**
    * **键是用来处理业务相关比如唯一性、连接等，但是索引是用来提高查询性能的！不是一个概念！！！！**
    * 在SQLServer中，**主键的创建必须依赖于索引**，默认创建的是聚集索引，即可以创建主键非聚集索引。
    * 创建主键后，不可以删除该索引。如果强制删除，那么主键也没了！！！


* 一条索引记录中包含的基本信息包括：键值（即你定义索引时指定的所有字段的值）+逻辑指针（指向数据页或者另一索引页）。

![](/assets/3俄方无的放矢大.png)

通常状况下，由于索引记录仅包含索引字段值（以及4-9字节的指针），索引实体比真实的数据行要小许多，索引页相较数据页来说要**密集许多**。一个索引页可以存储数量更多的索引记录，这意味着在索引中**查找时在I/O上占很大的优势**，理解这一点有助于从本质上了解使用索引的优势。


##
#######

[return](README.md)