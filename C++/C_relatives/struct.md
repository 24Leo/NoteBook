##对齐
**整体大小：每个变量对齐参数中最大那个对齐参数的倍数**
    * 嵌套时：内部结构体体现为外部结构体的一个变量
    * 内部结构体变量的对齐参数就自己内部最大对齐参数，而不是自己大小；
    
```C++
//注：sizeof(short)=2,sizeof(long)=4
struct{
    short a1;
    short a2;
    short a3;
}A;
struct{
    long a1;
    short a2;
}B;
sizeof(A)=6, sizeof(B)=8,为什么？
```
    * A中：a1是short2B，和8B比，按2B对齐，其他同，所以最后自己6B；
        * **自身对齐参数和默认对齐参数两个中较小的那个对齐自己**
        * **最终大小为所有对齐参数中最大的整数倍**
    * B中：a1是long4B，和8B比，按4B对齐，a2为short为2B，按2B对齐，总大小6B，但是不是4B的整数倍，所以对齐至8B；

* 嵌套类型
```c++
// *代表空格
struct S1{
    char a;          // #***    
    long b;          // ####
};
struct S2 {
    char c;          // #***
    struct S1 d;     // #### ####   4B对齐，真实分开
    long long e;     // #### ####
};
sizeof(S1) = 8B
sizeof(S2) = 24B.
```
    * S1中：a对齐参数大小1B，和8B比，按1B对齐，b对齐参数是4B，按照4B对齐，整体大小为4B整数倍，最终8B；（a后3B空格）
    * S2中：c按1B对齐，d是S1类型结构体，按照结构体S1中最大对齐，即b 4B对齐共占8B空间，e是8B按8B对齐，最终a+d+e + 补 = （1 + 3） + 8 + 8 + 4B= 24B；是8B的倍数；
        * **此时整体8B倍数，不是S1大小，而是e，因为S1体现为4B对齐**；
        * 注意内存是这样的，一行4B，#代表占用，*代表补空
        ```c++
            #*** ####      c和S1中a
            #### ****      S1中b和 补齐
            #### ####      整个e按8B对齐
        ```
        
####总结：
* 单变量按本身对齐参数和默认（一般为8B，可以变）参数较小的那个对齐自己；
* 整个结构体最终大小是最大对齐参数的整数倍；
* 嵌套类型：内部结构体按照自己内最大的对齐参数对齐自己；
    * 嵌套时找最大的：
        * 普通变量就是自己对齐参数；
        * 嵌套结构体：就是自己内最大的对齐参数；


[return](README.md)